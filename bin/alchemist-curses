#!/usr/bin/env ruby
# encoding: utf-8

$LOAD_PATH << "../lib"

require 'bundler'
Bundler.setup

require 'alchemist-server'
require 'ffi-ncurses'

host = ARGV[0] || 'localhost'
port = (ARGV[1] || 7900).to_i

def start(host, port)
  EventMachine.run do
    EventMachine.connect host, port, Handler
  end
end

module Handler
  include FFI::NCurses
  include EventMachine::Protocols::LineProtocol

  INVENTORY_LABEL = 'Inventory: '
  INVENTORY_SIZE = 64
  INVENTORY_WIDTH = INVENTORY_LABEL.length + INVENTORY_SIZE*2

  def post_init
    @lines_to_read = nil
    @border_win = newwin 22, 45, 0, 0
    @geo_win = newwin 20, 43, 1, 1
    @inventory_win = newwin 1, INVENTORY_WIDTH, 23, 0
  end

  def receive_line(line)
    if @lines_to_read
      @response << line
      @lines_to_read -= 1

      if @lines_to_read <= 0
        @lines_to_read = nil
        handle_command @command, @response
        @command = nil
        @response = nil
      end
    end
    if line =~ /^Welcome, alchemical friend/
      login
    elsif line =~ /^(see|messages) (\d+)$/
      @command = $1
      @lines_to_read = $2.to_i
      @response = ''
    else
      handle_command *line.split(' ',2)
    end
  end

  def draw_geo_border
    lr = '|'.ord
    tb = '-'.ord
    c = '+'.ord

    wborder @border_win,lr,lr,tb,tb,c,c,c,c
    wrefresh @border_win
  end

  def draw_geography(data)
    wclear @geo_win
    wmove @geo_win, 0, 0
    wprintw @geo_win, data.pad_to_unicode_monospace
    wmove @geo_win, 10, 20
    wrefresh @geo_win
  end

  def draw_inventory(data)
    wclear @inventory_win
    wprintw @inventory_win, "#{INVENTORY_LABEL}#{data.pad_to_unicode_monospace}"
    wrefresh @inventory_win
  end

  def handle_command(command, data = nil)
    case command
    when "hello" then login_success
    when "appeared" then appear_success
    when "see" then draw_geography data
    when "inventory" then draw_inventory data
    end
  end

  def login
    EM.defer(-> { prompt "Enter your name:" },
             -> name do
      @name = name
      send_data name
      send_data "\n"
    end)
  end

  def login_success
    printw "Appearing...\n"
    refresh
    send_data "appear\n"
  end

  def appear_success
    draw_geo_border
    look
    request_inventory
    action_loop
  end

  def look
    send_data "look\n"
  end

  def request_inventory
    send_data "inventory\n"
  end

  def act(char)
    case char
    when KEY_LEFT then move "west\n"
    when KEY_RIGHT then move "east\n"
    when KEY_UP then move "north\n"
    when KEY_DOWN then move "south\n"
    when 't'.ord then take
    end
  end

  def move(direction)
    send_data direction
    send_data "\n"
    look
  end

  def take
    send_data "take\n"
    look
    request_inventory
  end

  def prompt(text)
    printw text
    printw ' '
    answer = ''

    while (c = getch) != "\n".ord
      if c > 0
        answer << c
        printw (''<<c)
      end
    end

    printw "\n"
    refresh

    answer.strip
  end

  def action_loop
    EM.defer(-> { getch },
             -> c do
                act c
                action_loop
             end)
  end
end

class UI
  def initialize(handler)
    @h = handler
  end
end

begin
  # tell the terminal to enter curses mode
  FFI::NCurses.initscr
  FFI::NCurses.noecho
  FFI::NCurses.halfdelay 1

  FFI::NCurses.printw "Connecting.... to #{host}:#{port}\n"

  # causes changes to be displayed on the screen - maybe this means that NCurses
  # uses front and back buffers for drawing?
  FFI::NCurses.refresh
  FFI::NCurses.keypad FFI::NCurses.stdscr, true

  start host, port
ensure
  # returns back to regular console mode
  FFI::NCurses.endwin
end

