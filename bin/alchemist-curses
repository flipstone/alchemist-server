#!/usr/bin/env ruby
# encoding: utf-8

$LOAD_PATH << "../lib"

require 'bundler'
Bundler.setup

require 'alchemist-server'
require 'ffi-ncurses'
require 'alchemist-server/curses/item_window'
require 'alchemist-server/curses/prompt_window'
require 'alchemist-server/curses/glyph_window'

host = ARGV[0] || 'localhost'
port = (ARGV[1] || 7900).to_i

def start(host, port)
  EventMachine.run do
    EventMachine.connect host, port, Handler
  end
end

module Handler
  include FFI::NCurses
  include EventMachine::Protocols::LineProtocol

  INVENTORY_LABEL = 'Inventory: '
  INVENTORY_SIZE = 64

  BASICS_LABEL = 'Basics: '
  BASICS_SIZE = INVENTORY_SIZE

  COMPOUNDS_LABEL = 'Compounds: '
  COMPOUNDS_SIZE = INVENTORY_SIZE

  def post_init
    @lines_to_read = nil
    @border_win = newwin 22, 45, 0, 0
    @geo_win = newwin 20, 43, 1, 1

    @prompt_win = Alchemist::Curses::PromptWindow.new(
      23,
      0,
      80
    )

    @inventory_win = Alchemist::Curses::ItemWindow.new(
      INVENTORY_LABEL,
      INVENTORY_SIZE,
      24,
      0
    )

    @basics_win = Alchemist::Curses::ItemWindow.new(
      BASICS_LABEL,
      BASICS_SIZE,
      25,
      0
    )

    @compounds_win = Alchemist::Curses::ItemWindow.new(
      COMPOUNDS_LABEL,
      COMPOUNDS_SIZE,
      26,
      0
    )

    @error_win = newwin 1, 80, 27, 0
    @glyph_win = Alchemist::Curses::GlyphWindow.new 0, 46
  end

  def receive_line(line)
    if @lines_to_read
      @response << line
      @lines_to_read -= 1

      if @lines_to_read <= 0
        @lines_to_read = nil
        handle_command @command, @response
        @command = nil
        @response = nil
      end
    end
    if line =~ /^Welcome, alchemical friend/
      login
    elsif line =~ /^(see|messages) (\d+)$/
      @command = $1
      @lines_to_read = $2.to_i
      @response = ''
    else
      handle_command *line.split(' ',2)
    end
  end

  def draw_geo_border
    lr = '|'.ord
    tb = '-'.ord
    c = '+'.ord

    wborder @border_win,lr,lr,tb,tb,c,c,c,c
    wrefresh @border_win
  end

  def draw_geography(data)
    wclear @geo_win
    wmove @geo_win, 0, 0
    wprintw @geo_win, data.pad_to_unicode_monospace
    move_to_avatar_position
  end

  def update_inventory(data)
    @inventory_win.update data
    move_to_avatar_position
  end

  def update_basics(data)
    @basics_win.update data
    move_to_avatar_position
  end

  def update_compounds(data)
    @compounds_win.update data
    move_to_avatar_position
  end

  def move_to_avatar_position
    wmove @geo_win, 10, 20
    wrefresh @geo_win
  end

  def draw_error(error)
    wmove @error_win, 0, 0
    wprintw @error_win, "Last error: "
    wprintw @error_win, error
    wrefresh @error_win
    move_to_avatar_position
  end

  def handle_command(command, data = nil)
    case command
    when "hello" then login_success
    when "appeared" then appear_success
    when "see" then draw_geography data
    when "inventory" then update_inventory data
    when "basics" then update_basics data
    when "compounds" then update_compounds data
    when "error" then draw_error data
    end
  end

  def login
    EM.defer(-> { @prompt_win.ask "Enter your name" },
             -> name do
      @name = name
      send_data name
      send_data "\n"
    end)
  end

  def login_success
    printw "Appearing...\n"
    refresh
    send_data "appear\n"
  end

  def appear_success
    draw_geo_border
    look
    request_inventory
    request_basics
    request_compounds
    action_loop
  end

  def look
    send_data "look\n"
  end

  def request_inventory
    send_data "inventory\n"
  end

  def request_basics
    send_data "basics\n"
  end

  def request_compounds
    send_data "compounds\n"
  end

  def act(char)
    case char
    when KEY_LEFT then move "west\n"
    when KEY_RIGHT then move "east\n"
    when KEY_UP then move "north\n"
    when KEY_DOWN then move "south\n"
    when 't'.ord then take
    when 'p'.ord then put
    when 'c'.ord then create
    when 'e'.ord then element
    when 'f'.ord then forge
    end
  end

  def move(direction)
    send_data direction
    send_data "\n"
    look
  end

  def put
    if element = @inventory_win.have_user_select
      send_data "put #{element}\n"
      look
    end
  end

  def create
    if element = @basics_win.have_user_select
      send_data "create #{element}\n"
    end
  end

  def element
    if element = @glyph_win.have_user_select
      name = @prompt_win.ask "New Element Name"
      send_data "element #{element} #{name}\n"
      request_basics
    end
  end

  def forge
    if (ingred_1 = @inventory_win.have_user_select) &&
       (ingred_2 = @inventory_win.have_user_select) &&
       (result = @compounds_win.have_user_select)
      send_data "forge #{ingred_1} #{ingred_2} #{result}\n"
    end

  end

  def take
    send_data "take\n"
    look
  end

  def action_loop
    EM.defer(-> { getch },
             -> c do
                act c
                action_loop
             end)
  end
end

class UI
  def initialize(handler)
    @h = handler
  end
end

begin
  # tell the terminal to enter curses mode
  FFI::NCurses.initscr
  FFI::NCurses.noecho
  FFI::NCurses.halfdelay 1

  FFI::NCurses.printw "Connecting.... to #{host}:#{port}\n"

  # causes changes to be displayed on the screen - maybe this means that NCurses
  # uses front and back buffers for drawing?
  FFI::NCurses.refresh
  FFI::NCurses.keypad FFI::NCurses.stdscr, true

  start host, port
ensure
  # returns back to regular console mode
  FFI::NCurses.endwin
end

