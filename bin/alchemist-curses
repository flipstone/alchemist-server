#!/usr/bin/env ruby
# encoding: utf-8

$LOAD_PATH << "../lib"

require 'bundler'
Bundler.setup

require 'alchemist-server'
require 'ffi-ncurses'
require 'alchemist-server/curses/item_window'
require 'alchemist-server/curses/prompt_window'
require 'alchemist-server/curses/glyph_window'
require 'alchemist-server/curses/messages_window'
require 'alchemist-server/curses/geography_window'

host = ARGV[0] || 'localhost'
port = (ARGV[1] || 7900).to_i

def start(host, port)
  EventMachine.run do
    EventMachine.connect host, port, Handler
  end
end

module Handler
  include FFI::NCurses
  include EventMachine::Protocols::LineProtocol

  INVENTORY_LABEL = 'Inventory: '
  INVENTORY_SIZE = 64

  BASICS_LABEL = 'Basics: '
  BASICS_SIZE = INVENTORY_SIZE

  COMPOUNDS_LABEL = 'Compounds: '
  COMPOUNDS_SIZE = INVENTORY_SIZE

  AVATAR_COLOR_NUM = 1

  def post_init
    start_color
    init_pair AVATAR_COLOR_NUM, Color::BLACK, Color::GREEN

    @lines_to_read = nil
    @border_win = newwin 22, 45, 0, 0
    @geo_win = Alchemist::Curses::GeographyWindow.new(
      1, 1, AVATAR_COLOR_NUM)

    @location_win = newwin 1, 45, 23, 0

    @prompt_win = Alchemist::Curses::PromptWindow.new(
      24, 0, 80)

    @inventory_win = Alchemist::Curses::ItemWindow.new(
      INVENTORY_LABEL,
      INVENTORY_SIZE,
      25,
      0
    )

    @basics_win = Alchemist::Curses::ItemWindow.new(
      BASICS_LABEL,
      BASICS_SIZE,
      26,
      0
    )

    @compounds_win = Alchemist::Curses::ItemWindow.new(
      COMPOUNDS_LABEL,
      COMPOUNDS_SIZE,
      27,
      0
    )

    @error_win = newwin 1, 80, 28, 0
    @glyph_win = Alchemist::Curses::GlyphWindow.new 0, 46

    @messages_win = Alchemist::Curses::MessagesWindow.new(
      10, 80, 29, 0
    )
  end

  def receive_line(line)
    if @lines_to_read
      @response << line
      @lines_to_read -= 1

      if @lines_to_read <= 0
        @lines_to_read = nil
        handle_command @command, @response
        @command = nil
        @response = nil
      end
    end
    if line =~ /^Welcome, alchemical friend/
      login
    elsif line =~ /^(see|messages|avatars) (\d+)$/
      @command = $1
      @lines_to_read = $2.to_i
      @response = ''
    else
      handle_command *line.split(' ',2)
    end
  end

  def draw_geo_border
    lr = '|'.ord
    tb = '-'.ord
    c = '+'.ord

    wborder @border_win,lr,lr,tb,tb,c,c,c,c
    wrefresh @border_win
  end

  def update_geography(data)
    if @location
      @geo_win.update @location, data
    end
  end

  def update_location(data)
    x, y = data.split(/\s+/).map &:to_i
    @location = [x, y]
    draw_location *@location
    @geo_win.update_avatar @name, *@location
  end

  def draw_location(x, y)
    wclear @location_win
    wmove @location_win, 0, 0
    wprintw @location_win, "Location: #{x},#{y}"
    wrefresh @location_win
  end

  def update_inventory(data)
    @inventory_win.update data
    move_to_avatar_position
  end

  def update_basics(data)
    @basics_win.update data
    move_to_avatar_position
  end

  def update_compounds(data)
    @compounds_win.update data
    move_to_avatar_position
  end

  def update_messages(data)
    @messages_win.update data.split("\n")
    move_to_avatar_position
  end

  def move_to_avatar_position
    @geo_win.move_to_avatar_position
  end

  def draw_error(error)
    wmove @error_win, 0, 0
    wprintw @error_win, "Last error: "
    wprintw @error_win, error
    wrefresh @error_win
    move_to_avatar_position
  end

  def handle_command(command, data = nil)
    case command
    when "hello" then login_success
    when "appeared" then appear_success
    when "see" then update_geography data
    when "inventory" then update_inventory data
    when "basics" then update_basics data
    when "compounds" then update_compounds data
    when "error" then draw_error data
    when "messages" then update_messages data
    when "avatars" then update_avatars data
    when "location" then update_location data
    end
  end

  def update_avatars(data)
    locations = data.each_line.map do |line|
      name, x, y = line.split /\s+/
      { name => [x.to_i,y.to_i] }
    end

    @geo_win.update_avatars locations.reduce :merge
  end

  def login
    EM.defer(-> { @prompt_win.ask "Enter your name" },
             -> name do
      @name = name
      send_data name
      send_data "\n"
    end)
  end

  def login_success
    printw "Appearing...\n"
    refresh
    send_data "appear\n"
  end

  def appear_success
    draw_geo_border
    who
    request_location
    look
    request_inventory
    request_basics
    request_compounds
    read
    action_loop
  end

  def request_location
    send_data "location\n"
  end

  def look
    send_data "look\n"
  end

  def read
    send_data "read\n"
  end

  def request_inventory
    send_data "inventory\n"
  end

  def request_basics
    send_data "basics\n"
  end

  def request_compounds
    send_data "compounds\n"
  end

  def who
    send_data "who\n"
  end

  def act(char)
    case char
    when KEY_LEFT then move "west"
    when KEY_RIGHT then move "east"
    when KEY_UP then move "north"
    when KEY_DOWN then move "south"
    when 't'.ord then take
    when 'p'.ord then put
    when 'c'.ord then create
    when 'e'.ord then element
    when 'f'.ord then forge
    when 'F'.ord then formulate
    when 'm'.ord then post_message
    when 'r'.ord then read
    end
  end

  def move(direction)
    send_data direction
    send_data "\n"
    look
  end

  def put
    if element = @inventory_win.have_user_select
      send_data "put #{element}\n"
      look
    end
  end

  def create
    if element = @basics_win.have_user_select
      send_data "create #{element}\n"
    end
  end

  def element
    if element = @glyph_win.have_user_select
      name = @prompt_win.ask "New Element Name"
      send_data "element #{element} #{name}\n"
      request_basics
    end
  end

  def forge
    if (ingred_1 = @inventory_win.have_user_select) &&
       (ingred_2 = @inventory_win.have_user_select) &&
       (result = @compounds_win.have_user_select)
      send_data "forge #{ingred_1} #{ingred_2} #{result}\n"
    end
  end

  def formulate
    if (ingred_1 = @inventory_win.have_user_select) &&
       (ingred_2 = @inventory_win.have_user_select) &&
       (result = @glyph_win.have_user_select)
      name = @prompt_win.ask "Compound Name"
      send_data "formulate #{ingred_1} #{ingred_2} #{result} #{name}\n"
      request_compounds
    end
  end

  def post_message
    if message = @prompt_win.ask("Message (# msg)")
      send_data "message #{message}\n"
      read
    end
  end

  def take
    send_data "take\n"
    look
  end

  def action_loop
    EM.defer(-> { getch },
             -> c do
                act c
                action_loop
             end)
  end
end

class UI
  def initialize(handler)
    @h = handler
  end
end

begin
  # tell the terminal to enter curses mode
  FFI::NCurses.initscr
  FFI::NCurses.noecho
  FFI::NCurses.halfdelay 1

  FFI::NCurses.printw "Connecting.... to #{host}:#{port}\n"

  # causes changes to be displayed on the screen - maybe this means that NCurses
  # uses front and back buffers for drawing?
  FFI::NCurses.refresh
  FFI::NCurses.keypad FFI::NCurses.stdscr, true

  start host, port
ensure
  # returns back to regular console mode
  FFI::NCurses.endwin
end

